[ { "title": "Do it! 자료구조와 함께 배우는 알고리즘 입문 자바 편 리뷰", "url": "/posts/Do-it!-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%99%80-%ED%95%A8%EA%BB%98-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%9E%85%EB%AC%B8-%EC%9E%90%EB%B0%94-%ED%8E%B8-%EB%A6%AC%EB%B7%B0/", "categories": "프로그래밍 이론, IT서적 리뷰", "tags": "자료구조, 알고리즘, IT서적, 자바", "date": "2023-01-23 22:23:00 +0900", "snippet": "비전공자로서 기초도 바탕도 없지만 일단 부딪혀보자는 생각으로 백준 알고리즘을 하나씩 풀어보고 있었습니다. 그러나 얼마 안가 한계가 왔습니다. 더 이상 혼자 진도를 나가기가 힘겨워져 아무래도 알고리즘을 ‘공부’해봐야겠다는 생각에 이 책을 구매했습니다. 그리고 약 3개월이 넘어서야 겨우 1회독을 했습니다.알고리즘책에서 정의한 알고리즘은 다음과 같습니다. 어떤 문제를 해결하기 위한 절차로, 명확하게 정의되고 순서가 있는 유한 개의 규칙으로 이루어진 집합프로그래밍 상황에서 어떤 문제가 주어졌을 때, 저희는 이를 해결하기 위한 절차를 세워야 합니다. 알고리즘을 공부한 사람이라면 그 절차를 더욱 간결하게, 빠르게, 그리고 아름답게 다듬을 줄 알아야 할 것입니다. 책에서는 평범한 알고리즘을 먼저 보여주고 그것을 아름답게 가공해나가는 과정을 보여줍니다. 여기에서 복잡도(complexity)라는 개념이 등장합니다. 복잡도는 다음의 두 가지 요소를 가지고 있습니다. 시간 복잡도(time complexity) : 실행에 필요한 시간을 평가한 것 공간 복잡도(space complexity) : 기억 영역과 파일 공간이 얼마나 필요한가를 평가한 것백준 알고리즘 문제에서는 제출한 코드의 실행시간을 측정하고, 답이 맞았다고 해도 정해놓은 시간을 초과했을 시 틀렸다고 합니다. 이 때 저희는 만들어놓은 알고리즘의 시간복잡도를 고려하여 수정해야 할 것입니다. 책에서는 시간 복잡도를 고려하여 알고리즘을 개선하는 과정을 보여줍니다.자료구조 파트에서도 어딘가 불편하거나 허점이 있는 알고리즘을 여러차례 개선해나가는 과정을 보여줍니다. 스스로 쥐어짜낼때는 잘 모르지만, 이렇게 점점 아름다워지는 알고리즘을 보다보면 어쩐지 카타르시스가 느껴지고는 합니다.책의 후반부에서 나온 if문이 없이 for문만으로 이루어지는 ‘매우 아름다운 알고리즘’입니다. 회사에서 정신없이 코딩을 하다 보면 어쩔 수 없이 많아지는 if문 안의 else if문, 또 그 안의 조건문에도 길게 늘어지는 || 와 &amp;&amp;가 있을 때 왠지 모를 거부감이 느껴졌는데, 아름답지 못한 코드에 대한 본능적인 반응이었나 봅니다.코딩테스트를 준비하기 위한 마음으로 읽기 시작한 책이지만, 잘 쓰여진 알고리즘을 읽고 이해하고 개선시켜나가는 재미를 느낄 수 있었습니다. 한번 읽고 마는게 아니라 여러번 읽고 이해하고 따라하면서 습득해야 이득을 볼 책인 것 같습니다. 코딩테스트 뿐만 아니라 회사에서, 또는 개인프로젝트에서 배운것을 활용하며 아름다운 코드를 작성해 보고 싶습니다." }, { "title": "Spring boot를 사용한 RESTful Web Service 만들기", "url": "/posts/Spring-boot%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%9C-RESTful-Web-Service-%EB%A7%8C%EB%93%A4%EA%B8%B0/", "categories": "개발 실습", "tags": "Spring boot, REST API, JPA, 인프런", "date": "2022-12-22 22:03:00 +0900", "snippet": "‘동적인 웹 페이지를 만들기 위한 JAVA 웹 프로그래밍 기술‘이라는 포스팅에서 자바 웹 프로그래밍과 스프링에 대해서 정리한 적이 있습니다. 그 다음 이어지는 내용으로 스프링 부트로 만드는 RESTful Web Service에 대해서 정리하려고 합니다. 인프런의 다음의 강의를 수강했습니다.2년정도 전에 학원에 다닐때 배웠던 내용이 대부분인데 오랜만에 다시 배우려니까 꽤 어렵더라고요. 총 6시간 43분의 짧은 강의지만 체감으로는 꽤나 길었습니다. 이번 포스팅에서는 RESTful Web Service를 구성하는 RESTful API에 대해서 알아보고, 이후로는 스프링부트로 이를 구현해보려고 합니다.RESTful API란RESTful API에 대해서 설명하기 전에 API란 무엇인지에 대해서 먼저 얘기해 보도록 하겠습니다. 다음은 위키백과에 정의된 API와 인터페이스에 대한 내용입니다.API(Application Programming Interface) 응용 프로그램에서 사용할 수 있도록, 운영 체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스를 뜻한다인터페이스 2개 이상의 장치나 소프트웨어 사이에서 정보나 신호를 주고받을때 그 사이를 연결하는 연결장치나 경계면, 또는 연결하는 경계에서 상호 접속하기 위한 하드웨어, 소프트웨어, 조건, 규약 등을 말한다.인터페이스의 의미가 너무 넓어서 잘 와닿지 않을 수도 있습니다. 예를 들어 에어컨을 켜기 위해 손가락으로 에어컨 본체의 전원 버튼을 눌렀을 때, 손가락과 에어컨은 신호를 주고받았다고 할 수 있습니다. 이 때 에어컨의 전원버튼이 사람의 손가락과 에어컨을 연결해주는 인터페이스가 됩니다.인터페이스는 하드웨어 인터페이스, 소프트웨어 인터페이스, 사용자 인터페이스로 구분합니다. 그 중 소프트웨어, 그리고 그 중에서도 응용 프로그램 두 개를 연결하는 인터페이스를 API라고 합니다.또한 웹 API는 웹 프로그래밍에서 클라이언트와 웹 리소스 간의 통신 방 여기에서 클라이언트는 정보에 엑세스하려는 사용자이며, 리소스는 애플리케이션이 클라이언트에게 제공하는 정보를 의미합니다. RESTful API에서의 API는 웹 API를 의미합니다.REST는 Representational State Transfer의 약자로, REST 아키텍쳐 스타일을 따르는 API를 RESTful API라고 합니다. 이것은 URL(Uniform Resource Locator)을 사용하여 리소스를 식별합니다. 또한 HTTP 메서드를 사용하여 리소스에 수행해야 하는 작업을 서버에 알려줍니다. RESTful API를 통해 두 컴퓨터 시스템이 인터넷을 통해 정보를 안전하게 교환할 수 있습니다.RESTful API의 주요 규칙RESTful API의 주요 규칙은 다음의 두가지가 있습니다. 고유 리소스 식별자인 URL(Uniform Resource Locator)로 자원을 구분한다. 자원에 대한 행위는 HTTP Method로 표현한다.GET /user/1GET /user/99/post/1위와 같이 서버에서 리소스를 불러오는 두 개의 API가 있습니다. 위의 API는 첫번째 user의 정보를 가지고 오는 것이고, 아래의 API는 99번째 user가 첫번째로 작성한 포스트의 정보를 가지고 오는 것입니다. ‘자원을 구분한다’의 의미는 이와 같이 각각 다른 자원을 다른 URL로 명시하여 구분짓는 것을 의미합니다.HTTP 메서드의 종류는 다음과 같습니다. GET : 리소스를 조회한다. POST : 서버로 데이터를 전달한다. 주로 리소스를 새로 등록하는데에 사용. PUT : 리소스를 업데이트한다. DELETE : 리소스를 삭제한다.주로 사용하는 메서드 외의 다른 메서드는 다음을 참고해주세요. [2]HTTP 상태코드또한 RESTful API에서는 HTTP 상태코드를 통해 요청에 대한 응답의 상태, 즉 성공/실패 여부와 실패 이유 등을 표시합니다. 저는 간단한 웹 서비스를 개발할 때는 상태코드 설정의 중요성을 인지하지 못했는데, Cafe24의 패키징된 API를 사용할 때는 아주 유용하게 사용했던 경험이 있습니다.HTTP 상태코드의 첫번째 숫자에 따라 응답의 종류를 구분할 수 있습니다. 100번대 (Informational) : 조건부 응답 200번대 (Successful) : 성공 300번대 (Redirection) : 리다이렉션 완료 400번대 (Client Error) : 요청 오류 500번대 (Server Error) : 서버 오류간단한 RESTful Web Service를 만들때 주로 사용하게될 상태코드는 다음과 같습니다.200 OK : 요청이 성공적으로 수행되었습니다.201 Created : 요청이 성공적이었으며 그 결과로 새로운 리소스가 생성되었습니다.302 Found : 요청한 리소스의 URI가 일시적으로 변경되었음을 의미합니다.400 Bad Request : 잘못된 문법으로 인하여 서버가 요청을 이해할 수 없습니다.401 Unauthorized : 인증되지 않은 사용자의 요청입니다.403 Forbidden : 클라이언트가 콘텐츠에 접근할 권한을 가지고 있지 않음을 의미합니다. 401과 다른 점은 서버가 클라이언트가 누구인지 알고 있다는 것입니다.404 Not Found : 요청한 리소스를 찾을 수 없습니다. 또는 리소스가 존재하지 않습니다. 브라우저에서는 알려지지 않은 URL을 의미합니다.500 Internal Server Error : 서버가 처리방법을 모르는 오류가 발생했습니다.502 Bad Gateway : 서버가 게이트웨이로부터 잘못된 응답을 수신했습니다.504 Gateway Timeout : 서버가 게이트웨이 역할을 하고 있으며, 한 서버가 액세스하고 있는 다른 서버에서 적시에 응답을 받지 못했음을 의미합니다.더 많은 HTTP 상태코드는 다음을 참고해주세요.[3]이번 포스팅에서 RESTful API의 개념을 살펴보고 이를 구현하기 위한 URL, HTTP Method, HTTP상태코드에 대해서 정리해봤습니다. 다음 포스팅에서는 스프링부트로 해당 내용을 구현해보도록 하겠습니다.1. https://aws.amazon.com/ko/what-is/restful-api/ 2. https://developer.mozilla.org/ko/docs/Web/HTTP/Methods/3. https://developer.mozilla.org/ko/docs/Web/HTTP/Status/" }, { "title": "맥북m1 터미널 iterm2로 커스텀하기", "url": "/posts/%EB%A7%A5%EB%B6%81m1-%ED%84%B0%EB%AF%B8%EB%84%90-iterm2%EB%A1%9C-%EC%BB%A4%EC%8A%A4%ED%85%80%ED%95%98%EA%B8%B0/", "categories": "개발 실습", "tags": "맥, m1, 터미널, iterm2, zsh", "date": "2022-11-04 23:05:00 +0900", "snippet": "리눅스(또는 맥북) 터미널을 익숙하게 쓰면서도 동시에 꽤나 불편하게 써왔다는 것을 깨달았습니다. 격투게임에서 필살기를 쓰면 한번에 많은양의 피를 깎을 수 있으면서도, 복잡한 커맨드를 외우기 어려워서 평타만 치면서 찔끔찔끔 깎고 있었다고 하면 좋은 예시가 될지 모르겠습니다. 관성이라는 것은 사람의 발전을 해치고는 합니다.설치아무튼 이번에 맥북 m1 기본 터미널을 iterm2로 업그레이드 하면서 새로 공부한 내용을 정리해 보려고 합니다. 별 생각없이 다들 많이 쓴다고 하길래 터미널 앱은 iterm2로, 기본 shell은 zsh로 변경했는데 그게 이후로의 고난에 시작이 될 줄은 몰랐습니다. iterm2의 편리한 기능부터 확인하시고 설치를 고민하시기를 바랍니다. [1]간단하게 정리해드리면 창을 수직 또는 수평으로 분할하기 단축키로 등록하여 터미널 최상단으로 가져오기 검색기능 자동완성기능 키보드와 마우스를 사용한 텍스트편집 여러가지 옵션을 통해 터미널 설정하기 트리거 설정등등이 있습니다. 설치는 홈페이지에서 가능합니다. https://ooeunz.tistory.com/21그리고 디폴트 쉘 환경을 bash에서 zsh로 변경하도록 하겠습니다. zsh 쉘은 다음과 같은 장점을 가지고 있습니다. bash와 호환가능 플러그인 서치 가능 자동완성 기능 여러가지 테마 설정 기능설치는 다음과 같이 진행해주세요.아직 맥의 패키지 관리자인 brew가 안 깔려있을 경우에는 홈페이지 https://brew.sh/에 가서위의 설치 curl을 복사해서 터미널에 붙여넣기해서 설치합니다.그리고 homebrew로 zsh를 설치하고 디폴트 쉘로 변경합니다.$ brew install zsh$ chsh -s $(which zsh)zsh 설정 관리 프레임워크인 oh-my-zsh를 홈페이지 https://ohmyz.sh/#install에 가서역시 위의 설치 curl을 복사 붙여넣기해서 설치합니다.iterm2와 zsh를 설치했다면 이제 터미널을 예쁘게 커스텀해보도록 하겠습니다. 저는 이런 모양으로 커스텀해서 사용하고 있습니다.커스텀에 대한 건 이 블로그[2]에서 너무 잘 설명해주셨기 때문에 넘어가고, bash셸에서 zsh로 넘어가면서 바뀐 환경설정 또는 주의해야할 점에 대해서 정리하려고 합니다.아키텍쳐 설정커스텀까지 마치고 흐뭇하게 터미널을 보고 있었는데, 터미널을 바꾸기 전까지는 잘 실행되던 것들이 오류가 나기 시작합니다. 첫번째로 jekyll 정적 사이트 생성기로 이 블로그를 만들었는데, 블로그를 로컬서버에서 돌리기 위한 jekyll serve 명령어가 듣지 않았습니다.서치해서 나온 해결방법은 다음과 같았습니다. iTerm 아이콘 우클릭 &gt; 정보 가져오기 &gt; Rosetta로 실행 ruby 재설치 또는 bundle 재설치여기에서 Rosetta는 Inter 프로세서가 장착된 Mac용으로 제작된 앱을 Apple Silicon이 장착된 Mac에서 사용할 수 있게 해주는 앱입니다. 하지만 오류는 여전했고, 저는 오류 로그의 -have ‘arm64’, need ‘x86_64’ 문구를 힌트로 얻어 다음과 같이 문제를 해결했습니다.$ arch -arm64 jekyll serve여기에서 arch는 architecture의 약어로 시스템의 아키텍쳐를 의미합니다. arch 명령어를 사용하면 실행한 터미널 환경과 상관없이 특정 아키텍쳐로 앱을 실행할 수 있게 됩니다. [3] 즉, 위의 명령어는 arm64 아키텍쳐로 jekyll 서버를 실행한다는 의미가 됩니다. 참고로 Intel 프로세서 아키텍쳐는 x86_64이고 Apple Silicon M1은 arm64입니다. 이를 바탕으로 왜 이런 오류가 났는지 원인을 찾아보자면먼저 iterm2의 아키텍쳐를 확인해봅시다.Inter x86_64로 나옵니다.기본 터미널에서 아키텍쳐를 확인하면arm64로 나옵니다.기본 터미널에서 먼저 arm64 아키텍쳐로 jekyll을 다운받았기 때문에 iterm2로 jekyll 서버를 실행할때 역시 arm64로 해야하는 것이었습니다. 저와 같은 상황이신분이 있다면 꼭 아키텍처를 염두에 두시기를 바랍니다.단축키iterm2의 단축키에 대해 정리해보려고 합니다. 단축키를 외우는게 당장은 귀찮을지 모르지만, 나중에 터미널을 여러개 띄워두고 복잡한 작업을 해야할 때는 훨씬 효율적인 개발을 할 수 있을 것입니다. 예전에 TCP 분산서버 동시접속 테스트 위해 putty 창 5개를 띄워놓고 했던 때가 떠올랐습니다. 그 때도 지금보다 더 좋은 방법은 없을지 부지런히 찾아보고 공부해보면서 개발했더라면 그런식으로 하지는 않았을것 같습니다.참고로 이거 하나는 창,이건 각각 탭이고,이건 각각 Pane(틀)입니다.창/탭/Pane 컨트롤 새 창 : Cmd + N 새 탭 : Cmd + T 창 세로분할 : Cmd + D 창 세로분할 : Cmd + D Pane 닫기 : Cmd + W 창 닫기 : Cmd + Shift + W 전체 창 닫기 : Cmd + Shift + Opt + W 탭 닫기 : Cmd + Opt + W 숨기기 : Cmd + H 현재 창 최소화 : Cmd + M 모든 탭 모든 Pane 동시에 입력 : Cmd + Shift + I 현재 탭 모든 Pane 동시에 입력 : Opt + Cmd + I 다음 Pane으로 : Cmd + ] 이전 Pane으로 : Cmd + [ 탭 순차 이동 : Control + tab 다음 탭으로 : Cmd + Shift + ] 이전 탭으로 : Cmd + Shift + [ 이전 탭으로 : Cmd + Shift + [입/출력 복사 : Cmd + C 붙여넣기 : Cmd + V 전체 선택 : Cmd + A 전체 검색 : Cmd + Option + E 검색 : Cmd + F 검색(다음으로) : Cmd + G 검색(이전으로) : Cmd + Shift + G clear\t: Cmd + K 클립보드 : Command + Shift + H 자동완성 : Command + ; 작업시간 보여주기 : Command + Shift + E커서 이동 커서 좌로 이동 : Ctrl + B 커서 우로 이동 : Ctrl + F 커서 좌측 끝으로 이동 : Ctrl + A 커서 우측 끝으로 이동 : Ctrl + E 현재 단어 좌측 끝으로 커서 이동 : ESC + B 현재 단어 우측 끝으로 커서 이동 : ESC + F 현재 커서의 우측 문자 삭제 : Ctrl + D 현재 커서 위치부터 맨 끝까지 삭제 : Ctrl + K 전체 삭제 : Ctrl + U 현재 커서 좌측 단어 삭제 : Ctrl + W 현재 커서 우측 단어 삭제 : ESC + D 현재 커서의 단어와 좌측의 단어의 위치를 변경 : ESC + Titerm 사용하면서 의식적으로 단축키를 입력해가면서 외워보도록 합시다. 이번 포스팅은 여기서 마치도록 하겠습니다. 다들 멋지고 즐겁게 개발하시길 바랍니다!1. https://iterm2.com/features.html2. https://ooeunz.tistory.com/213. https://subicura.com/mac/dev/apple-silicon.html#apple-silicon-m1" }, { "title": "자바 프로그램 개발을 위한 3대 핵심기술", "url": "/posts/%EC%9E%90%EB%B0%94_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8_%EA%B0%9C%EB%B0%9C%EC%9D%84_%EC%9C%84%ED%95%9C_3%EB%8C%80_%ED%95%B5%EC%8B%AC%EA%B8%B0%EC%88%A0/", "categories": "프로그래밍 이론", "tags": "JAVA", "date": "2022-10-21 01:30:00 +0900", "snippet": "JAVA저희가 자바에 대해서 얘기할 때 그것은 프로그래밍 언어로서의 자바일 수도 있지만, 소프트웨어 플랫폼으로서의 자바일 수도 있습니다. 소프트웨어 플랫폼으로서의 자바란 자바(언어)로 기술된 프로그램 개발 및 실행을 할 수 있는 소프트웨어 모임의 총칭입니다. [1]위의 그림은 오라클에서 제공하는 자바 플랫폼 구성요소 다이어그램입니다. 너무 복잡하니까 중요한 것만 집고 넘어가겠습니다. 다음의 세가지는 자바 플랫폼의 3대 구성요소입니다. JDK(Java Development Kit - 자바 개발 키트) JVM(Java Virture Machine - 자바 가상머신) JRE(Java Runtime Environment - 자바 런타임 환경)이 세가지 기술은 서로 연결되어 동작하며 개발자가 작성한 자바 프로그램을 작성할 수 있게 하고, 그것을 실행시킬 수 있게 합니다.JDKJDK는 개발자들이 JVM과 JRE에 의해 실행할 수 있는 자바 프로그램을 개발할 수 있게 해줍니다. 자바 애플리케이션 구동에 이용되는 JRE와 자바 컴파일러를 포함하고 있습니다. 컴파일러는 개발자가 프로그래밍 언어로 작성된 프로그램(.java)을 기계어, 즉 컴퓨터가 이해하는 언어로 된 파일(.class)로 바꿔줍니다.컴파일러가 하는 일이 무엇인지 더 정확히 이해하기 위해 JDK를 설치하여 직접 사용해보는 실습을 해보려고 합니다. 먼저 원하는 버전으로 openjdk를 다운로드합니다.$ brew install --cask adoptopenjdk8만약 8 외에 여러버전의 jdk를 설치하셨다면 다음의 명령어를 통해 설치된 jdk의 목록을 확인하실 수 있습니다.$ /usr/libexec/java_home -V저는 이렇게 14,11,8 버전의 jdk를 설치해둔 상태입니다. 여기에서 원하는 버전으로 변경하고 싶으시면$ export JAVA_HOME=$(/usr/libexec/java_home -v 1.8)다음과 같이 환경변수를 설정하여 변경할 수 있습니다. 설정 후 아래의 명령어로 자바 버전을 확인해보면$ java -version1.8로 변경된 것을 보실 수 있습니다. 이제 다운받은 jdk를 사용하여 간단한 Hello, World!를 출력하는 프로그램을 만들어보겠습니다. 터미널에서 vim 편집기로 바로 HelloWorld.java라는 자바 소스코드 파일을 작성했습니다.$ vim HelloWorld.java그리고 다음의 코드를 입력하고 저장해주세요.javac 명령어는 jdk를 다운받을때 포함되어있던 자바 컴파일러입니다. 이 컴파일러를 이용해 .java 파일을 .class파일로 컴파일합니다.$ javac HelloWorldHelloWorld.class 파일이 생성된 것을 보실 수 있습니다. 생성된 .class파일을 vim 편집기로 열어봅시다.이전에 입력했던 소스코드와는 달리 알아볼 수 없는 기계어로 이루어져있는 것을 확인하실 수 있습니다.$ java HelloWorld위의 java 명령어는 생성된 class파일을 실행시키는 역할을 합니다. 위의 명령어를 실행하면다음과 같이 실행결과로 Hello, world!가 출력되는 것을 확인하실 수 있습니다. 관례상 실행시켜보긴 했지만 여기에서는 컴파일러의 일을 하는 javac 명령어에 대해서 이해하는 것이 중요합니다. 저희가 개발할 때 주로 사용하는 IDE(통합개발환경)에서는 개발자 대신 컴파일 작업을 관리해주고 있습니다. 이클립스의 Preference &gt; Java &gt; Compiler에서 JDK 컴파일러에 대한 옵션을 확인하고 설정할 수 있습니다. JDK 컴파일러 스냅샷JREJRE는 컴퓨터 운영체제 위에서 실행되면서 부가적인 서비스를 제공하는 소프트웨어 계층입니다. 그래서 자바 프로그램을 거의 모든 운영체제에서 수정 없이 실행되도록 합니다. 그래서 자바 프로그램 실행에 필요한 라이브러리와 소프트웨어를 포함하고 있습니다. 또한 운영체제를 기반으로 그 이상의 부가가치 서비스를 제공합니다.그 중 자동 메모리 관리(Automatic memory management)는 프로그래머가 메모리 할당과 재할당을 수동으로 조작할 필요가 없게 해줍니다. 자바 클래스 로더는 컴파일된 자바 코드를 메모리로 로드하고 적절한 자바 클래스 라이브러리에 연결합니다. 그리고 코드를 실행할 JVM을 시작합니다.JRE는 개발 단계에서는 운영체제 또는 IDE에서 프로그램을 실행할 뿐이므로 개발자가 직접적으로 사용할 일은 드뭅니다. 하지만 저희는 IDE에서 자바 프로그램을 개발할 때 JRE를 종종 발견할 수 있었을 것입니다.자바 프로젝트를 생성하면 자동으로 생성되는 이 JRE System Library를 펼쳐보면 자바 프로그램 실행에 필요한 라이브러리를 갖추고 있음을 확인할 수 있습니다.아니면 어떠한 오류를 해결하기 위해 프로젝트의 Java Build Path에 들어가서 JRE System Library의 path를 다시 설정해보신 적이 있을겁니다.이런 식으로 JRE가 자바 프로그램 실행을 돕고 있다는 것을 유추해볼 수 있습니다.JVMJVM은 시스템 메모리를 관리하면서 자바 기반 애플리케이션에 이식 가능한 ‘실행 환경을 제공’합니다. 여기서 이식 가능하다는 것은 사용중인 운영체제 또는 실제로 존재하는 하드웨어에 관계없이 프로그램이 실행가능한 환경을 조성한다는 것을 의미합니다. 쉽게 말해 “한번 작성해, 어디에서나 실행” 가능하다는 것입니다.JVM 구성요소 [3]JVM의 주요 구성 요소는 위의 그림과 같이 클래스 로더(Class Loader), 실행 엔진(Excution Engine), 런타임 데이터 영역(Runtime Data Area)으로 구성되어 있습니다.(1) 클래스 로더는 프로그램 실행시 필요한 클래스를 JVM 메모리에 로드합니다.(2) 자바 실행 엔진은 파일,네트워크 그리고 메모리 리소스를 요구하는 프로그램 실행과 운영체제 가운데 위치해서 이런 리소소들을 공급합니다. 힙 메모리 영역에 생성된 객체들 중에서 참조되지 않는 객체들을 찾아서 제거하는 가비지 컬렉터를 포함하고 있습니다.(3) 런타임 데이터 영역은 JVM의 메모리 영역으로 자바 애플리케이션을 실행할 때 사용되는 데이터들을 적제합니다. 이를 용도에 따라 3가지 영역으로 나누면 메소드 영역(Method Area), 스택 영역(Stack Area), 힙 영역(Heap Area)로 나눌 수 있습니다.메소드 영역은 인터페이스 상수, 멤버변수, 스태틱 변수, 메소드 등 클래스나 인터페이스의 정적인 데이터가 들어가는 부분입니다. 스택 영역은 콜 스텍이라고도 부르며, 메소드를 호출하면 그 메소드가 할당되는 곳입니다. 메소드가 반환되면 메모리도 반환되어 비어집니다. 힙 영역은 참조 타입의 동적 메모리 할당 객체, 즉 인스턴스 객체가 들어가는 곳입니다.다음과 같이 JAVA 프로그램 개발을 위한 3가지 기술에 대해 알아보았습니다. 게임을 할때 공략해야 할 대상의 정보를 알아두는 것은 필수입니다. 앞으로 함께 속속들이 파해쳐 나가봅시다.1. 참고 https://ko.wikipedia.org/wiki/%EC%9E%90%EB%B0%94_(%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4_%ED%94%8C%EB%9E%AB%ED%8F%BC) 2. 참고 https://www.itworld.co.kr/techlibrary/111080 3. 참고 https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html" }, { "title": "CGI 프로그래밍 맛보기", "url": "/posts/CGI-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%A7%9B%EB%B3%B4%EA%B8%B0/", "categories": "개발 실습", "tags": "아파치, 도커, CGI", "date": "2022-10-17 23:20:00 +0900", "snippet": "잠시 쉬어가는 시간으로 지난번 스프링 포스팅에서 잠깐 나왔던 CGI 프로그래밍 구현과정을 포스팅하겠습니다. CGI(Common Gateway Interface)란 사용자에게 동적 웹페이지를 보여주기 위한 최초의 기술로, 웹 서버와 외부 프로그램 사이에서 정보를 주고받는 규약입니다. 리처시할때 97년도 자료까지 봤으니 저같은 신입 개발자분들에겐 다소 생소할 아주 오래된 기술입니다. CGI 동작과정위의 그림을 보면 CGI의 동작과정에 대해 이해할 수 있습니다. 브라우저에서 보낸 요청을 웹서버가 CGI 인터페이스를 통해 CGI 프로그램에 전달 CGI 프로그램은 데이터베이스와 통신하여 동적인 페이지를 그려냅니다. 그려낸 페이지를 웹 서버를 통해 브라우저에 전달합니다.그리고 다음의 서블릿과 CGI를 비교 표를 통해 CGI의 특성을 이해해봅시다. 서블릿 vs CGI번역이 서투르니 원문[1]을 보시는걸 추천드립니다. 오늘날 CGI를 거의 사용하지 않는 이유는 아무래도 위 그림의 비용 문제가 가장 클 것입니다. 프로세스 단위로 실행이 되다보니 사용자의 요청이 많아지면 서버의 부하가 크게 갔던 것입니다.이것만으로는 CGI의 정체가 무엇인지 감이 잘 안올 수 있습니다. 그래서 docker 컨테이너에 아파지 웹서버를 올려 간단하게 CGI 프로그램을 만들어 보았습니다.원래 도커 컨테이너를 실행할 때는 run 명령어를 써서 바로 이미지를 다운받아 실행해왔지만, 이번에 ubuntu 이미지를 다운받아 실행시키려고 하니 바로 Exit되는 현상이 있었습니다. 예를 들어 이렇게 컨테이너 이름을 cgitest로 지정하고 ubuntu 이미지를 실행시킨 뒤에$ docker run --name cgitest ubuntu해당 명령어로 모든 도커 컨테이너의 목록을 확인하면$ docker ps -a이렇게 STATUS가 Exit로 되어있습니다. 이유가 무엇일까요? Docker의 컨테이너는 Virtual machine과 같이 하나의 온전한 서버를 제공하는게 아니라 명령을 실행하는 환경만 제공하고 그 명령을 실행할 뿐입니다. 이렇게 명령어를 지정해주지 않았을 때는 default 명령어인 /bin/bash만 실행하고 컨테이너는 종료됩니다.그래서 저는 다음과 같은 방법으로 우분투 서버의 shell에 접속했습니다.docker create -p 81:80 -it —name cgitest ubuntu /bin/bashdocker start cgitestdocker attach cgitestubuntu shell을 백그라운드로 실행한 뒤 docker attach 명령을 이용하여 컨테이너에 접속하였습니다. 이에 대한 자세한 설명은 [2]를 참고해주세요.하얀 도화지같은 새로생긴 ubuntu 서버에 접속한 뒤에는 다음과 같은 명령어로 아주 간단한 1차적인 설정만 해주겠습니다.apt updateapt install apache2apt install net-toolsapt install vim그리고 설치한 apache 웹서버를 실행시켜보겠습니다.service apache2 start이제 로컬에서 81번 포트로 도커 컨테이너의 80번 포트에 접속할 수 있습니다.도커 컨테이너에서 아파치2가 실행되고있다는걸 확인할 수 있는 아주 아름다운 아파치의 기본 화면입니다. 이제 [3]를 참고하여 아파치 웹서버와 연결되는 CGI 프로그램을 제작해보겠습니다.컨테이너의 OS인 ubuntu 20.04LTS에서는 아파치 설정파일이 /etc/apache2/apache2.conf에 있었습니다. 아까 다운받은 vim 편집기로 이 설정파일에 다음의 설정을 추가해줍니다.78번 라인에서 해당 경로의 cgi 모듈을 로드하고,79번 라인에서 해당 디렉토리의 파일들을 cgi 프로그래밍 용으로 둡니다.80~87번 라인에서 해당 디렉토리에서 CGI 실행을 허용하고 권한을 부여합니다. 이제 cgi 프로그램으로 사용하기로 설정한 경로에 가서 CGI 프로그램을 작성해 보겠습니다. 먼저 기본적인 Hello 문구를 찍어보는 first.pl 스크립트부터 작성해보았습니다.1번 라인은 프로그래밍 언어중 perl을 사용한다는 의미입니다.2번 라인은 html로 출력하겠다는 의미입니다.3번 라인에서 Hello, CGI를 출력하고 있습니다.아파치 설정파일의 79번 라인에서 매핑한 /cgi-bin/ 경로의 파일을 주소창에 입력하면, CGI 프로그램에서 html 페이지를 출력하는 것을 확인할 수 있습니다.하지만 이는 CGI를 사용하는 이유인 동적 페이지랑은 거리가 멀어 보입니다. 사용자의 요청에 따라 달라지는 동적 페이지를 구현하기 위해 같은 경로에 hello_post.pl 이라는 CGI 프로그램을 작성해 보았습니다.내용이 좀 길지만 3번 라인에서 변수를 지정하고7번 라인에서 POST메서드와 GET메서드를 분기시키고21번 라인에서 받은 HTTP요청을 파싱하고 파라미터를 변수에 저장한 뒤29번,30번 라인에서 각각 새로운 변수에 담아32번 라인에서 출력하는 것을 알 수 있습니다.여기서 perl 문법까지 이해하려고 할 필요는 없을 것 같습니다.작성한 프로그램이 POST요청에 대해서 동적인 페이지를 출력하는 것을 테스트해보기 위해 포스트맨으로 실행해봤습니다.POST METHOD으로 파라미터 first_name과 last_name을 HTTP 요청으로 보냈더니 hello_post.pl이 해당 값이 담긴 html 페이지를 출력한 것을 확인할 수 있었습니다.이와 같이 CGI 프로그래밍을 통해 동적인 페이지를 생성해보았습니다. 설정이 간단하니 한번 따라해보시면 위의 CGI 동작과정과 특성이 이해가 가실 거라고 생각합니다. 이제는 쓰지않는 기술 공부해봤자 무슨 의미가 있냐고 하신다면… 도커 사용법 연습이라고 생각합시다.추가)어디선가 사용하고 있는 곳이 없을까 했는데, 아파치 공식 웹사이트의 다운로드 페이지가 cgi 프로그래밍을 쓰고있네요! 다른 페이지는 .html이고 다운로드 페이지만 .cgi로 되어 있습니다. 위의 실습과 함께 보시면 해당 웹페이지가 어떤 구조로 만들어져 있는지 이해하기 쉬우실것 같습니다.1. 참고 https://www.geeksforgeeks.org/differene-between-java-servlet-and-cgi/2. 참고 https://www.popit.kr/%EA%B0%9C%EB%B0%9C%EC%9E%90%EA%B0%80-%EC%B2%98%EC%9D%8C-docker-%EC%A0%91%ED%95%A0%EB%95%8C-%EC%98%A4%EB%8A%94-%EB%A9%98%EB%B6%95-%EB%AA%87%EA%B0%80%EC%A7%80/3. 참고 https://httpd.apache.org/docs/2.4/ko/howto/cgi.html" }, { "title": "동적인 웹 페이지를 만들기 위한 JAVA 웹 프로그래밍 기술", "url": "/posts/%EB%8F%99%EC%A0%81%EC%9D%B8-%EC%9B%B9-%ED%8E%98%EC%9D%B4%EC%A7%80%EB%A5%BC-%EB%A7%8C%EB%93%A4%EA%B8%B0-%EC%9C%84%ED%95%9C-JAVA-%EC%9B%B9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EA%B8%B0%EC%88%A0/", "categories": "프로그래밍 이론", "tags": "자바, 스프링, 인프런, CGI", "date": "2022-10-15 21:30:00 +0900", "snippet": "최근에 자바와 스프링을 더 깊게 파기로 결심했습니다. 저는 원래 상당한 잡식성으로 어떤 개발환경에서라도 즐겁게 배우고 적응할 자신이 있지만, 자바와 스프링을 주력으로 삼기로 한 이유는 현재 제가 속한 금융이라는 도메인을 더 명확히 하고 싶기 때문입니다. 그래서 그 첫 단추로 인프런의 JAVA → Servlet&amp;JSP → Spring으로 이어지는 연계 강의를 들었습니다.이 강좌를 선택한 이유는 기초부터 빠르게 훑으며 이전에 학원에서 배웠던 내용을 상기해보기 위해서였습니다. 결과적으로 두달정도 걸리긴 했네요. 자바와 스프링을 처음 접하시는 분들에게는 몇가지가 생략되어 빠르게 넘어가는 듯한 느낌이 있을 수도 있지만, 저처럼 이미 알던 내용을 복습하고 정리하는 분들에게는 알맞은 강의라고 생각합니다. 강의를 들으면서 배운 내용을 개념 위주로 간단하게 정리해보려고 합니다.웹 프로그래밍우리들의 컴퓨터는 네트워크 통신망에 의해 서로 연결되어 있습니다. 그래서 저희는 정보를 찾거나 저장하는 등 특정 목적을 위해서 네트워크 통신망을 타고 인터넷의 웹 사이트에 접속할 수 있습니다. 예를 들어 구글에서 ‘전두엽을 깨우는 블로그’의 글을 보기 위해 사용자는 검색창에 해당 블로그의 이름을 검색하여 검색 결과를 받아볼 것입니다. 그리고 링크를 타고 들어오게 됩니다. 그로 인해 사용자는 저 멀리 지구 어딘가에 있는 이 블로그를 돌리는 중의 서버컴퓨터와 연결되게 됩니다.사용자가 브라우저의 검색창에 ‘전두엽을 깨우는 블로그’를 검색하면 사용자는 구글의 웹 서버에 요청(Request)를 보내게 됩니다. 그리고 구글은 사용자에게 검색결과 리스트를 응답(Response)합니다. 또 사용자가 링크를 타고 들어올 때, 블로그의 웹 서버에 블로그를 보여달라는 요청을 보내게 됩니다. 그러면 웹 서버는 사용자에게 웹 페이지를 응답합니다. 이렇게 사용자가 요청했을 때 웹 서버에서 데이터를 수집하고 가공하여 다시 응답하는 과정을 만드는것을 웹 프로그래밍이라고 합니다.사용자는 웹 서버에 정적 데이터를 요청할 수 있습니다. 예를 들어 회사 소개 페이지가 있습니다. 이는 요청에 대한 응답으로 회사를 소개하는 그림이나 문구가 쓰여진 변하지 않는 HTML 페이지를 보여줄 뿐입니다. 또 사용자는 요구하는 조건에 따라 데이터를 새로 수집하고 가공하여 변화하는 동적 데이터를 요청할 수도 있습니다. 검색창에 ‘구글’을 검색했을 때와 ‘전두엽을 깨는 블로그’를 검색했을때 페이지에 서로 다른 검색결과가 나오는 것을 예로 들수 있습니다. 이 때 웹 서버는 WAS(Web Application Server)라는 것에 위의 그림과 같이 데이터베이스에 저장된 데이터의 일부를 검색하여 가져오는 쿼리를 던지고 그 결과를 받아옵니다. WAS는 동적인 데이터 처리를 하는 서버입니다.CGI위와 같이 사용자에게 동적 데이터를 전달하기 위한 기술로 서블릿 이전에 CGI(Common Gateway Interface)가 있었습니다. CGI 이전에는 오직 정적인 html파일만 보여줄 수 있었습니다. 그 번거로움이 상상이 가십니까? 아무튼 CGI는 웹 서버가 동적인 페이지를 만드는 외부 프로그램과 통신할 수 있도록 해주는 기술입니다.[1] 은 대표적인 웹서버인 아파치에서 CGI를 활용한 동적 페이지를 생성하는 매뉴얼입니다. 매뉴얼을 따라 간단한 아파치 CGI 프로그램을 만들어보았습니다. 포스트맨으로 CGI 프로그램이 동작하는 모습웹서버에 이름과 성 두개의 파라미터를 넣어서 요청을 보내고 ‘Hello,’ 뒤에 출력하는 프로그램입니다. 파라미터의 값이 달라지면 프로그램은 다른 내용의 페이지를 보여줄 것이고, 이는 CGI가 동적인 페이지를 만들 수 있다는 것을 의미합니다. 자세히 설명하면 너무 길어질 것 같아서 이 내용은 따로 포스팅하도록 하겠습니다.서블릿서블릿은 자바를 사용하여 웹페이지를 동적으로 생성하는 기술입니다. 서블릿은 자바 코드 안에 HTML을 포함하고 있으며, 웹 요청에 대한 결과를 처리한 후 이에 대한 응답을 HTML로 내보냅니다.그래서 서블릿은 이런 모습을 하고 있습니다. HttpServlet 추상클래스를 상속받은 클래스 안의 method는 브라우저로부터 요청을 받으면 해당 요청에 대한 데이터를 처리한 후 html과 함께 응답으로 내보냅니다. 요청에 대한 데이터 처리로는 데이터베이스서 필요한 데이터를 꺼내오고 가공하거나, 쿠키 또는 세션을 처리하거나 할 수 있습니다.서블릿은 WEB-INF 폴더 안에 web.xml 파일로 존재하는 환경 설정 파일을 가지며, 이를 배치 지시자(Deployment Descriptor)라고 합니다. 배치 지시자에서 우리는 여러가지 환경 설정을 할 수 있는데, 그 중 하나가 서블릿 매핑입니다. 서블릿 매핑web.xml에 다음과 같은 설정을 추가함으로써 com.servlet.ServletEx라는 클래스를 서블릿으로 등록하고, 그 서블릿에 /SE라는 URL을 매핑할 수 있습니다. 이렇게 해서 브라우저에서 /SE라는 주소를 요청하면 등록된 클래스와 연결될 수 있습니다.이렇게 만들어진 서블릿은 스스로는 동작할 수는 없고, 이를 관리해주는 서블릿 컨테이너에 의해 동작할 수 있습니다. 서블릿 컨테이너는 클라이언트의 요청을 받고 이에 대해 응답할 수 있도록 웹 서버와 소켓으로 통신합니다. 또한 멀티스레딩을 지원하며, 서블릿의 라이프사이클을 관리합니다. 톰캣(tomcat)은 서블릿 컨테이너의 대표적인 예입니다. 서블릿 통신 구조정리해보면 사용자가 브라우저에서 보내는 요청은 웹 서버를 통헤 먼저 서블릿 컨테이너에 전달됩니다. 요청을 전달받은 서블릿 컨테이너는 서블릿을 생성하고 실행시키는데, 이는 서블릿을 구현한 클래스가 인스턴스화되어 실행되는 것을 의미합니다. 그리고 실행된 결과로 HTML 페이지를 웹 서버에 전달하고, 웹 서버는 이를 브라우저에 전달합니다.스프링스프링으로 넘어가기 전에 웹 프로그래밍 설계 모델 중 MVC패턴에 대해서 먼저 얘기하려고 합니다. MVC패턴은 가장 보편적인 웹 프로그램 아키택쳐이며, 모델(Model), 뷰(View), 컨트롤러(Controller)를 가지는 구조를 의미합니다. 모델은 내부 비즈니스 로직을, 뷰는 사용자 인터페이스를, 컨트롤러는 사용자 요청을 처리합니다.예를 들어 회원가입 기능을 구현하려고 합니다. 그러기 위해선 사용자가 이름과 아이디 등 회원정보를 입력하는 화면이 존재해야 합니다. 이렇게 사용자에게 보여지며 입력을 받는 화면을 뷰라고 합니다. 회원정보를 입력한 후 회원가입 버튼을 누르면 서버에서는 해당 업무를 수행하라는 요청을 받아 처리해야 하는데, 이러한 역할을 하는 것이 컨트롤러입니다. 컨트롤러는 회원정보 데이터를 담고 이를 데이터베이스에 저장하는 역할을 하는 모델을 호출하게 됩니다. 이처럼 컨트롤러는 뷰와 모델 사이에서 중개자 역할을 하며 사용자의 요청을 처리하게 됩니다.MVC패턴에는 두가지 종류의 모델이 있습니다. 아래는 MVC Model1과 Model2입니다.Model1에서는 뷰와 컨트롤러를 하나의 JSP 페이지에서 구현합니다. 사용자 인터페이스에서 입력을 받고, 해당 요청을 처리하기 위해 모델과 상호작용하고 다시 화면을 그려내는 코드를 하나의 JSP에 작성한다는 것입니다. 이는 프로그램의 흐름이 단순하여 개발이 쉽고 생산속도가 빨라 중소형 프로젝트에 적합합니다. 하지만 이러한 개발이 진행됨에 따라 프로젝트가 커지면서 JSP페이지가 계속해서 늘어난다고 생각해봅시다. 단순하지만 모든 페이지에 적용되어야 하는 작은 기능을 넣어야 할때 개발자는 모든 페이지의 코드를 일일히 수정해야 할 것입니다. 이러한 불필요한 유지보수 비용을 덜기 위해 Model2 구조를 선택할 수 있습니다.Model2는 컨트롤러와 뷰를 분리하여 클라이언트의 입력과 요청 처리에 대한 로직을 독립적으로 수행합니다. 각각의 기능이 모듈화돼있다고 표현할 수 있습니다. 하나의 컨트롤러에 있는 기능을 수정하면 해당 컨트롤러에 연결된 모든 뷰의 기능을 수정할 수 있습니다. 따라서 유지보수할때 불필요한 비용이 덜어진다고 볼 수 있습니다. 하지만 프로그램의 흐름이 복잡하여 초기 개발이 쉽지 않을 것입니다. 그럼에도 불구하고 대부분의 프로젝트는 이러한 모델의 구조를 따르고 있습니다.Model2에 대해서 이해하면 스프링의 구조를 이해하기 쉬워집니다. 스프링은 Model2의 구조를 따르고 있습니다. 그리고 DispatcherServlet에 의해 Controller와 View가 연결되어 서로 요청과 응답을 주고받을 수 있습니다. 스프링 동작 구조위의 그림에서는 DispatcherServlet을 기반으로 작동하는 스프링의 구조를 나타내고 있습니다. 순서대로 정리하면 다음과 같습니다. 브라우저의 요청을 DispatcherServlet이 제일 먼저 받습니다. DispatcherServlet은 HandlerMapping에게 갑니다. HandlerMapping은 브라우저에서 보낸 요청과 알맞는 Controller 객체를 찾아서 DispatcherServlet에게 해당 정보를 줍니다. DispatcherServlet은 Controller에 대한 정보를 가지고 HandlerAdapter에게 갑니다. HandlerAdapter는 받은 Controller에서 알맞는 메소드를 찾아 실행한 후 해당 결과를 반환합니다. DispatcherServlet은 마지막으로 View에게 갑니다. View는 JSP형태의 응답을 브라우저에 보냅니다.이 DispatcherServlet의 정체는 대체 무엇이길래 이런 역할을 수행할 수 있는걸까요? web.xml의 DispatcherServlet 설정위의 그림은 스프링에서 DispatcherServlet을 사용하기 위해 web.xml 파일에서 설정한 모습입니다. 여기서 web.xml은 위에서 서블릿 매핑에 대해서 설명할때 나온 배치지시자 web.xml과 같습니다. 그래서 이를 DispatcherServlet을 서블릿으로 등록한다고 할 수 있습니다.서블릿 매핑에 대한 개념을 잊지 않았다면 위 그림에 대해서 이해하는 것은 어렵지 않습니다. springframework 라이브러리 내부의 DispatcherServlet이란 클래스를 appServlet이란 이름으로 서블릿으로 등록합니다. 또한 프로젝트 내부의 servlet-context.xml파일을 파라미터로 지정하여 스프링 빈(Bean)을 등록하는 설정파일의 역할을 하도록 합니다. 그리고 전역 URL과 매핑합니다. 이를 통해 DispatcherServlet은 당연하게도 자바 코드로 쓰여진 class의 형태를 하고 있다는 것을 알 수 있습니다. 앞으로 저희는 스프링을 공부하며 왠 듣도보도못한 어려운 개념과 마주할 수도 있습니다. 그 때마다 어차피 class파일 여러개로 이루어져있을 뿐이라고 생각하면 조금이나마 쉽게 느껴질 것입니다.그 외에도 스프링의 4대 요소, 메이븐과 그래들, 스프링 시큐리티, 스프링 웹플럭스 등 다뤄야 할 내용이 너무나 많습니다. 이번 포스팅을 시작으로 앞으로 차근차근 공부해가며 정리하도록 하겠습니다.모든 공부하는 개발자분들 파이팅입니다!1. 참고 https://httpd.apache.org/docs/2.4/ko/howto/cgi.html" }, { "title": "소프트웨어 장인 리뷰", "url": "/posts/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4-%EC%9E%A5%EC%9D%B8-%EB%A6%AC%EB%B7%B0/", "categories": "프로그래밍 이론, IT서적 리뷰", "tags": "소프트웨어 장인, 개발자 커리어, IT서적", "date": "2022-09-21 21:46:00 +0900", "snippet": "산드로 만쿠소 저자의 소프트웨어 장인을 읽었습니다. 기술서적이 아니라 자기계발서라서 부담없이 가볍게 읽을 수 있는 책입니다. 만 2년차인 지금은 저자의 경험에 크게 공감이 가지는 않았으나, 나중에 10년차의 시니어가 됐을 때 다시 읽으면 느끼는게 많을 것 같습니다. 책에서는 애자일 방법론과 TDD, XP 등의 기술적 관례들을 중요하게 여기고 있지만, 궁극적으로 말하고자 하는건 소프트웨어 개발자가 가져야할 마음가짐과 태도에 대해서입니다. 소프트웨어 장인정신에 대한 설명 중에서 제일 인상깊게 읽었던 것은 다음의 문장입니다. 장인은 일종의 삶의 철학이다. 우리의 삶 전체에 걸쳐서 최선을 다해 역량을 마스터할 과업으로 소프트웨어 개발을 선택한 것이다.책을 읽다보면 저자의 개발에 대한 열정이 크게 와닿습니다. 그의 열정은 브라질 시골의 어린 시절부터 대성한 유럽의 개발자인 지금까지도 한결같아 보입니다.누구나 처음 개발을 시작할 때는 호기심과 열정으로 가득했을 것입니다. 그러나 막상 시작하게된 회사 업무는 로망과 다르고, 일정에 쫓기고 사람에게 치이며 권태감이 올 수도 있습니다. 내가 짠 코드의 가치를 의심하기도 하고 말이죠. 그럼에도 포기하지 않고 다시 열정을 불태울 수 있는 이유는 매달 들어오는 월급…이 아닌 개발을 진정으로 즐기기 때문이라고 생각합니다.우리는 주5일 9시에서 6시, 사람에 따라 그보다도 훨씬 많은 시간을 일에 투자합니다. 일생을 통틀어 계산해본다면 그 시간은 결코 그냥 흘러가도 좋을 것이 아닙니다. 이 아까운 시간들을 의미있게 보내려면 회사에서 하는 나의 업무를 진심으로 대해야 할 것입니다. 내가 만든 프로그램이 단지 값싼 소모성 상품이 아닌 혼이 담긴 작품이라고 생각해야 할 것입니다. 몇몇 개발자 또는 애자일 코치들이 소프트웨어 장인정신 커뮤니티가 엘리트 개발자들의 자발적인 모임이라고 하는 것에 놀랐다. 소프트웨어 장인정신이 엘리트 주의라고 생각한다면 이는 소프트웨어 장인을 오해하는 것이다. 소프트웨어 장인은 항상 다른 사람에게 배우려 하는 겸손할 사람이어야 하고 경험이 적은 개발자와 지식을 공유하기를 주저하지 않는 사람이어야 한다.소프트웨어 장인이라는 공동체의 사람들은 대단한 경력과 실력을 가졌음에도 아주 열정적이고 배움의 자세를 갖췄으며 겸손하기까지 합니다. 실제 업무현장에서 일하다보면 모두가 그들처럼 이상적인 개발자의 모습을 하고 있지는 않습니다. 물론 저자도 그걸 알고 있으며 수없이 겪어봤을 것입니다. chapter5에서는 저자의 유쾌하지 않았던 프로젝트경험에 대한 얘기가 나옵니다. chapter14에서는 개발팀에 변화를 도입할때 마주치는 빌런(?)들을 나열해놓기도 했습니다. 하지만 저자는 그들과 소통하고 때로는 싸우기까지 하는 것을 꺼리지 않는 것처럼 보였습니다. 엘리트라는 특권의식에 사로잡히지 않고 이렇게 회사 사람들과 진심으로 마주 대하는 것이 저자의 대단한 점이라고 생각합니다.사실 개발자는 권위적인 엘리트와는 반대로 자유분방한 느낌이 있긴 합니다. 저는 그래서 이 직업을 좋아합니다.업무현장에서 일할 때의 어려움에 대해서 얘기했는데, 짧은 경력이지만 제가 업무를 하면서 가장 어렵다고 느낀 것은 사람들의 방어적인 태도였습니다. 비개발자가 관리자일 때, 또는 현업일때, 아니면 디자이너 혹은 기획자일 때, 그들은 개발자가 하는 업무를 잘 이해하지 못할 수도 있습니다. 어려운 용어들이 많이 나와서 이해하기 힘들고, 괜히 불필요한 절차를 시간들여 하는 것 같기도 합니다. 그들이 일을 안하기 위해 어려운 용어로 자신에게 혼란을 준다고 생각할 수도 있습니다. 이에 개발자는 설명해봤자 소용없다고 느끼고 소통을 포기할 수도 있습니다. 그래서 저는 협업을 하면서 팀원들끼리 신뢰관계를 쌓는 것이 상당히 중요하다고 생각합니다. 그러한 과정들이 소모적이라며 등한시하면 좋은 프로젝트 결과물은 나오지 않을 것입니다. 부디 방어적인 태도를 버리고 열린 마음으로 서로의 말에 귀를 기울였으면 합니다.책에서는 개발자뿐만이 아니라 비개발자인 관리자와 면접관에게도 많은 얘기를 해주고 있습니다. 개발자 뿐만 아니라 개발자와 함께 일하는 직군들도 이에 대해 함께 고민해보셨으면 합니다. 갑자기 예전에 표지를 보고 호기심이 들었던 책이 생각나서 찾아왔습니다.이 책도 읽어보고 리뷰를 작성할 날이 왔으면 좋겠습니다. 다음에는 자료구조 책으로 다시 찾아오겠습니다." }, { "title": "맥북m1에 오라클DB 설치하는 법", "url": "/posts/%EB%A7%A5%EB%B6%81m1%EC%97%90-%EC%98%A4%EB%9D%BC%ED%81%B4DB-%EC%84%A4%EC%B9%98%ED%95%98%EB%8A%94-%EB%B2%95/", "categories": "개발 실습", "tags": "맥북, 오라클, m1, 맥북 에어", "date": "2022-08-20 20:44:00 +0900", "snippet": "회사에서 오라클 데이터베이스를 상당히 비중있게 다루고있고, 마침 인프런으로 듣던 강의에서도 오라클을 사용하길래 이번기회에 현재 제가 사용하고있는 노트북인 맥북 m1에 오라클 데이터베이스를 세팅해보기로 했습니다. 맥 OS는 오라클을 지원하지 않기 때문에 도커를 사용합니다만 맥북 m1에서 도커가 잘 안 돌아가는 듯 합니다. 다행히 정리된 포스팅들이 있어 삽질이 오래 가지는 않았으나, 앞으로 개발할때마다 계속 써야할것같기 때문에 정리해두려고 합니다.맥북 m1에서 오라클을 사용하기 위해 필요한 것은 다음과 같습니다. 오라클을 돌리기 위한 도커 설치 도커를 돌리기 위한 colima 설치 로컬에서 연결하기 위한 sql developer 설치도커 설치$ brew install docker도커는 터미널에 다음의 명령어를 입력하여 손쉽게 설치할 수 있었습니다. 하지만 노트북을 종료 후 다시 켜면이런식으로 연결이 종료되어 docker와 docker desktop을 완전히 삭제하고 재설치하기도 했습니다만, 여전히 다음 날이 되면 똑같은 상태더라고요. 그래서 colima를 사용해야된다는걸 몇시간의 삽질 끝에 깨달았습니다.colima 설치설치 전에 어떤 소프트웨어인지 알아보기 위해 잠시 공식 깃허브로 이동해봅시다.https://github.com/abiosoft/colima인텔과 맥 m1에서 CLI Interface를 사용하여 도커 컨테이너를 실행시켜주는 컨테이너 런타임 소프트웨어라고 합니다. 쿠버네티스도 지원하는 아주 바람직한 소프트웨어네요. 설치해봅시다.$ brew install colima설치 후, x86_64 환경으로 실행시켜줍니다.$ colima start --memory 4 --arch x86_64colima 실행 후 다시 docker 명령어를 입력하니 정상적으로 작동합니다. 이후에 colima가 잘 돌아가고 있는지 확인하려면 다음의 명령어를 입력해줍니다.$ colima statusdocker에 oracle-xe 설치이제 docker에서 jaspeen/oracle-xe-11g 이미지를 다운받아 컨테이너에서 실행시킴으로서 오라클 서버를 띄우겠습니다.$ docker run --name oracle11g -v ~/Desktop/Repository/oracledb:/u01/app/oracle -p 1521:1521 -d jaspeen/oracle-xe-11g‘-v’ 이 옵션을 통해 호스트와 볼륨을 공유함으로써 컨테이너를 재실행해도 이전의 데이터가 유지됩니다.이제 컨테이너 로그를 실시간으로 모니터링해보겠습니다. 그만두려면 Ctrl+C를 입력하시면 됩니다.$ docker logs -f oracle11g데이터베이스 사용준비가 되었다고 하네요. 이제 sql developer로 연결해보겠습니다. 사용자이름 : system 비밀번호 : oracle 호스트이름 : localhost 포트 : 1521다음으로 도커 컨테이너의 오라클 데이터베이스에 접속할 수 있습니다.앞으로는 재접속시에 다음과 같은 순서로 오라클을 실행시킬 수 있을 것 같습니다. colima 실행$ colima start --memory 4 --arch x86_64 docker container 실행$ docker start oracle11g oracle developer로 접속추가)며칠 후 jdbc와 docker에서 돌아가는 oracle을 연결해보려고 하니… 이런 오류가 떴습니다.검색해보니 가상환경의 disk가 꽉차서 그렇다고 하네요.https://stackoverflow.com/questions/23743910/ora-12528-tns-listener-all-appropriate-instances-are-blocking-new-connections컨테이너 재실행해줬습니다." }, { "title": "객체지향의 사실과 오해 리뷰", "url": "/posts/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%9D%98-%EC%82%AC%EC%8B%A4%EA%B3%BC-%EC%98%A4%ED%95%B4-%EB%A6%AC%EB%B7%B0/", "categories": "프로그래밍 이론, IT서적 리뷰", "tags": "객체지향의 사실과 오해, 객체지향, IT서적", "date": "2022-08-11 22:00:00 +0900", "snippet": "배민의 조영호님 저자의 객체지향의 사실과 오해를 읽었습니다. 책의 난이도는 전공서적처럼 이론이 빼곡히 차들어있지는 않지만 일반 교양서적처럼 쉽게 술술 넘어가는 것도 아닙니다. 객체지향으로 프로그램을 하나 설계해본 경험이 있으면 이해하기가 수월할 것입니다.(그냥 따라쳐본 경험이라도 그 과정에서 이해하고자 하는 노력이 있었다면 괜찮습니다.)학원출신의 비전공자 개발자라면 초반에 객체지향에 대한 개념을 간단하게 배우고 넘어갔을 것입니다. 생소한 개념을 짧은 시간에 완벽하게 이해하는 사람은 드물 것이고, 그마저도 그 이후에 정신없이 진도를 빼느라 잊어버렸을 것입니다. 그 과정에서 캡슐화, 상속, 추상화, 다형성을 적용하여 코드를 작성해봤지만, 그 과정이 상당히 번거롭고 ‘그런데 왜 이렇게 귀찮게 해야 하는가?’ 라는 생각이 들었을 수도 있습니다. 이 책에서는 그 의문을 해소해 줍니다.책에는 좋은 객체지향 프로그래밍을 설계하기 위한 방법이 많이 나와 있습니다. 기본적인 4가지 특징인 캡슐화, 상속, 추상화, 다형성 외에도 책임주도 설계, 디자인패턴, 테스트주도 개발 등이 있습니다. 이것들에 대한 개념을 이미 아는 내용이라고 소흘하게 넘어가면 안 될 것입니다. 단순히 코드의 모양을 아는 것과 책에서 설명하는 개념들과 함께 흐름을 이해하는 것은 큰 차이가 있습니다.그래서 이러한 방법들을 사용해서 얻는 이점이 무엇인가 하면 객체가 협력적이고 자율적이 됩니다. 객체들이 하나의 역할로 단순화되고, 다양한 객체들이 협력에 참여하여 협력이 유연해지며, 다양한 객체들이 동일한 협력에 참여하여 재사용성이 높아집니다. 그래서 이렇게 하면 프로그램으로서 뭐가 좋은가? 객체지향의 원칙을 잘 지켜서 만들어진 프로그램은 사용자가 원하는 기능을 빠르고 안정적으로 추가할 수 있게 됩니다.프로그램은 한번 만들어서 배포하고 나면 끝나는 것이 아니라 계속해서 사용자의 요구사항을 반영하여 업그레이드 해 나가야 합니다. 그래서 새로운 기능을 기존의 구조를 변경하는 일이 없이 빠르게 추가할 수 있다는 것은 상당히 중요한 일입니다. 객체지향을 공부하시다가 내가 왜 이런 어려운걸 이해해야 하며 번거로운 코드를 작성해야 하는가? 하면 이 사실을 떠올리면 좋을 것 같습니다.처음 한권 읽는데에 10시간정도 걸린 것 같습니다.(순수 읽은시간만 따지면 그렇고 일수로는 2주정도 걸렸습니다.) 비교적 가볍게 읽기 좋은 책이니 부담없이 2회독, 3회독도 가능할 것 같습니다. 하지만 저는 지루함을 못 견디는 성격이라 다른 책으로 다시 돌아오겠습니다." }, { "title": "금융 IT 시스템에 대한 이해", "url": "/posts/%EA%B8%88%EC%9C%B5-IT-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%97%90-%EB%8C%80%ED%95%9C-%EC%9D%B4%ED%95%B4/", "categories": "프로그래밍 이론", "tags": "금융IT, IT시스템", "date": "2022-07-16 23:27:00 +0900", "snippet": "금융권 IT회사에서 일하기 시작한지 6개월정도가 지났지만, 작지 않은 규모의 서비스를 운영함에 있어서 배경지식이 부족하여 겪는 불편함을 항상 느끼고 있습니다. 그래서 앞으로 금융IT분야에서 개발자로 일하기 위해 필요한 지식을 차근차근 공부해나가려고 합니다.금융계 IT 시스템의 도입 목적 금융거래의 편의성 제고 금융정보의 효율적 처리 효과 인터넷뱅킹, 스마트폰뱅킹 등 -&gt; 금융정보의 편의성 제고 업무가 신속, 정확하게 처리 -&gt; 효율성 제고 부작용 IT시스템의 다양화, 복잡화 -&gt; 고도의 운영기술 필요 -&gt; 운영리스크 증대 네트워크화 -&gt; 전산사고 피해규모의 대형화 및 피해 확산 과거에는 현금이라는 지급수단을 사용했고, 이를 주고 받는 업무를 할 시에 거래자가 직접 현금을 들고 이동해야 했습니다. 그러나 현재는 IT시스템의 도입으로 인해 전자지급수단을 사용하게 되면서 빠르고 간단하게 이를 주고 받을 수 있게 되었습니다. 이는 모두가 잘 아는 사실입니다.여기서 주목해야할 것은 아무래도 부작용인 것 같습니다. 금융서비스가 제공하는 기능이 다양해지고 사용하는 사람들의 수가 늘어날수록 IT시스템은 더 다양하고 복잡하게 진화하게 됩니다. 이 복잡한 시스템을 운영하기 위해 전문가들은 팀을 이루고, 팀별로 지정받은 시스템을 별도로 운영하고 있습니다. 그렇다보니 시스템 오류 상황에서 원인을 찾아내기가 쉽지 않아졌습니다. 수백대로 나눠진 시스템에서 문제상황이 어디에서 발생했는지 찾아내기가 어려워진 것입니다.또한 각각의 시스템이 네트워크로 연결된 구조도 부작용을 낳을 수 있습니다. 시스템 하나의 장애가 이와 연결된 다른 시스템과의 장애로 퍼지고, 이를 반복하면서 피해규모는 걷잡을 수 없이 커지게 됩니다. 시스템이 지연되어 서비스를 이용하지 못할 시에는 곧바로 커다란 비용적 손실로 이어지게 됩니다.금융계 IT 개발시스템의 특징위에서 서술한 이유 등으로 금융권 IT시스템 개발업무는 상당히 보수적인 특징을 가지고 있습니다. 아래와 같은 특징들은 전부 보수적인 성향을 가지고 있다고 볼 수 있습니다. 오류 처리에 민감합니다.금융권에서는 하나의 트랜잭션이 돈 처리를 의미하기 때문에 오류에 민감합니다. 0.1원 반올림에 대한 잘못된 처리가 1억원의 금전적 손실로 이어질 수 있습니다. 그래서 거래 업무는 빠른 개발이나 배포보다 안정적인 개발과 배포를 더 중요하게 생각합니다. 정형화된 업무와 정형화된 데이터은행 업무가 대부분 안정되어 있어서 변화가 적고 데이터도 대부분 정형화되어 있습니다. 그래서 프로세스 설계와 데이터 설계가 매우 중요하게 다뤄집니다. 이기종 DB(서로 다른 DBMS)나 복잡하게 시스템이 얽혀있는 N-Tier(다층구조) 환경이 대부분입니다. 시스템의 수정은 기피하며, 기존 시스템을 확장하는 방향으로 개발합니다.사소한 변경이 큰 금전적 손실로 이어질 수 있기 때문입니다. 유지보수가 중요하기 때문에 기술지원이 안정적인 솔루션들과 피해를 책임질 수 있는 전문 업체를 선호하는 경향이 있습니다. 그래서 신기술 도입이 더딘 편입니다. SOA 아키택쳐가 적용된 시스템이 많다.Monolichic Architecture, Microservice Architecture(MSA)와 대응됩니다. Service Oriented Architecture(SOA)는 기업의 업무 단위로 묶어서 서비스 하는것입니다. 데이터작업이 많고 처리속도가 중요하다.서버작업에 Oracle과 Pro*C가 많이 사용됩니다. 최근에는 Java가 많이 도입되어 있습니다. 이렇듯 금융계에서는 도전적인 기술을 사용하지 않기 때문에 기술보다는 ‘은행 업무’를 얼마나 잘 이해하고 있느냐가 경력직 채용의 중요한 기준이 됩니다. 은행업무를 모르면 비즈니스 로직을 짤 수 없기 때문입니다. 금융권에서 Java를 사용하는 이유최근에는 금융권에 Java가 많이 도입이 되어 있습니다. 저희 회사도 Java를 사용하고요. 금융권에서 Java를 주로 사용하는 이유는 다음과 같습니다. 하드웨어나 특정 기술 구조에 의존적인 개발은 하지 않아도 됩니다.Java는 JVM 위에서 작동하기 때문에 이식성과 범용성이 좋습니다. 처음에 사용했던 C/C++은 OS에서 직접 컴파일되는 시스템 언어로 CPU의 성능을 100%까지 끌어낼 수 있습니다. 그러나 OS가 달라지면 재컴파일해야합니다.기업 또는 Enterprise의 대규모 시스템에서 무거운 Batch처리나 가벼운 조회트랜잭션이 섞일 수밖에 없다보니 하드웨어 특성에 관계없이 Server가 운영될 필요가 생깁니다. 이것이 Java와 Spring이 주로 사용되는 이유입니다.앞으로의 금융IT 발전방향핀테크는 finance+technology의 합성어로, 약 5년 전 등장해 이미 새로운 금융 시장의 시대를 열었습니다. 모바일,빅데이터,사물인터넷,클라우드,인공지능 등 IT기술의 발달과 함께 성장하고, 새로운 서비스를 창출해내고 있습니다. 우리나라에는 삼성,네이버,카카오,토스 등 선두적인 IT 기업들이 그 중심에서 이끌어나가며, 온라인상에서 ActiveX, 공인인증서, 복잡한 결제 프로세스 등의 문제점을 단번에 해결해내고 급격하게 성장하고 있습니다.위에서 실컷 금융IT계열의 보수적인 특징에 대해서 설명했지만, 핀테크에서 내세우는 것은 바로 ‘혁신’입니다. 보수성향의 금융산업과 개발적인 IT산업의 성향이 융합되어 금융산업의 근본적인 변화를 주도하고 있는 것입니다.빠르게 변화하는 금융IT시장에 맞추어 해당 분야에 종사하는 개발자 역시 자신에 대한 투자를 아끼지 않는 융합형 인재로 성장할 필요성이 있어 보입니다.많은 정보가 빼곡하게 들어있는 포스팅은 아니어도 제가 공부한 것들을 완벽하게 이해하여 저만의 언어로 재구성하고싶은 생각이 있었으나… 어려운 기술용어가 나오고, 포스팅의 뒤로 갈수록 힘이 빠지는게 느껴지네요. 늘 그렇지만 아직 공부가 많이 부족함을 또 깨닫습니다. 이번에는 마치 교양처럼 금융IT산업의 전반적인 이해를 넓고 얕게 하기 위한 포스팅이었다면, 다음에는 좀더 시스템 중심의 전문적인 얘기를 다뤄볼까 합니다.참고금융IT시스템에 대한 이해 https://www.bok.or.kr/portal/bbs/B0000217/view.do?nttId=10045105&amp;menuNo=200144&amp;listType=G&amp;pageIndex=12﻿은행의 IT시스템에 대한 이해 https://subokim.wordpress.com/2015/05/11/it_system_of_bank/" }, { "title": "내가 보려고 모은 직장인 사이드 프로젝트", "url": "/posts/%EB%82%B4%EA%B0%80-%EB%B3%B4%EB%A0%A4%EA%B3%A0-%EB%AA%A8%EC%9D%80-%EC%A7%81%EC%9E%A5%EC%9D%B8-%EC%82%AC%EC%9D%B4%EB%93%9C-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/", "categories": "커리어 여정", "tags": "IT동아리, 사이드 프로젝트", "date": "2022-07-02 15:11:00 +0900", "snippet": "회사에서 하는 일 외에 실력을 키우고 싶다는 생각에 여러 IT동아리에 지원했지만, 무서운 경쟁률과 함께 탈락을 반복하고 있습니다. 바로 어제 결과가 나온 DND 7기 선발에서는 약 800명의 신청자가 있었다고 합니다. 열정적인 분들이 참 많다는 생각이 듭니다.혼자 하다보면 프로젝트 스케일의 한계도 있지만 끝없이 늘어지기 마련입니다. 믿을만한 운영진들이 이끌어주고, 동기부여가 되는 팀원들이 함께하고, 완성까지 시간이 정해져있다면 부족한 의지력을 매꿀 수 있지 않을까 생각합니다. 대략적인 목표는 이렇습니다. 일년에 하나씩 사이드 프로젝트 완성하기포스팅은 계속 업데이트 될 예정입니다. IT동아리, 대회, 공모전, 프로그램 등이 포함되어있습니다.IT 동아리대학생만 지원가능한 곳은 제외했습니다.NEXTERS공식사이트 : http://teamnexters.com/ 페이스북 : https://www.facebook.com/Nexterspage/현재까지 진행된 기수가 20기로 오랜기간 성공적으로 진행해오고 있습니다.모집기간은 5월/11월입니다.DND공식사이트 : https://www.dnd.ac/페이스북 : https://www.facebook.com/DNDACADEMY/공식홈페이지에 기수마다 이탈자 수를 명시해 놓는데 상당히 적은 편입니다. 프로젝트를 하다보면 이탈자가 없는것만으로도 충분히 성공적이라고 생각합니다.프로젝트 모집 외에 세미나 헤커톤 등 다른 이벤트도 활발하게 개최하는 듯 합니다. 모집기간은 6월/12월입니다.YAPP공식사이트 : https://www.yapp.co.kr/페이스북 : https://www.facebook.com/yapp.co.kr/역시 20기까지 오랜기간 진행해오고 있습니다. 기획자를 선발하는게 특이합니다.올해는 3월, 작년에는 1월/8월에 모집했습니다.DDD미디움 : https://dddstudy.medium.com/페이스북 : https://www.facebook.com/dddstudy작년에는 1월/7월, 올해에는 3월에 모집했습니다.디프만홈페이지 : https://depromeet.com/미디움 : https://depromeet.medium.com/페이스북 : https://www.facebook.com/depromeet인스타 : https://www.instagram.com/depromeet/2월/8월에 모집합니다.Mash Up홈페이지 : https://www.mash-up.kr/페이스북 : https://www.facebook.com/mashupgroup/Product Design, Spring, Node, Web, Android, iOS로 각각 나뉘어 팀을 빌딩합니다.올해 3월, 작년 6월, 재작년 1월, 11월에 신입을 모집했습니다. 대략 10개월정도 주기로 모집하는 듯 합니다.Fun.d홈페이지 : https://fun-d.site/네이버 카페 : https://cafe.naver.com/eofl7942유투브 : https://www.youtube.com/channel/UC1BRoMHI8Ucq11l60c3b89w여기도 기획자를 모집합니다.참가비 20만원에 수료 후 15만원 환급, 나머지는 MVP팀에게 상금과 운영비용으로 지급됩니다. 환급 시스템과 MVP선발이 있어서 적지않은 각오로 임할 수 있을 것 같습니다.올해 1월 모집했고 매년 초 정도에 모집하는 듯 합니다.프로그라피홈페이지 : https://prography.org/페이스북 : https://www.facebook.com/thePrography/코로나때문에 잠시 쉬었다가 올해 1월에 모집했습니다. 7월에 이전기수의 최종발표 후 모집이 있지 않을까 합니다.피로그래밍홈페이지 : https://pirogramming.com/페이스북 : https://www.facebook.com/pirogramming인스타 : https://www.instagram.com/pirogramming_official/비전공자들을 위한 웹프로그래밍 동아리라고 합니다. Python과 Django로 웹개발을 합니다.6월/12월 모집합니다.메이커스(CMC)홈페이지 : https://www.makeus.in/인스타그램 : https://www.instagram.com/makeus_challenge/유투브 : https://www.youtube.com/results?search_query=%EC%BB%B4%EA%B3%B5%EC%84%A0%EB%B0%B0유투브에서 자주 보이던 분들이네요. 대학생들을 위한 UMC와 직장인들을 위한 CMC로 나눠져있습니다.7월 모집 예정이라고 합니다.SWYG홈페이지 : https://www.swygbro.com/인스타그램 : https://www.instagram.com/swyg_official기수제는 아닌 듯 하여 제외하려고 했으나 기수제도 운영하는 듯 합니다. 6월에 2기를 모집했는데 7월말에 3기를 모집한다고 합니다. 여러 기수가 동시에 운영되나봅니다.루비콘홈페이지 : https://lubycon.io/mentoring/intro/미디움 : https://lubycon.medium.com/훌륭하신 멘토님들이 이끄는 멘토링 프로젝트가 있습니다. 작년 6월에 2기를 모집한 것 같은데 올해는 아직 소식이 없네요.영리단체비사이드홈페이지 : https://bside.best/25만원의 참가비를 받고 있으며 6개월 이상 경력의 현업만 가능합니다. 3월/5월 모집했습니다.프로그램오픈소스 컨트리뷰션 아카데미공식사이트 : https://www.contribution.ac/정보통신산업진흥원에서 주관하는 공개SW사업으로 오픈소스에 기여할 수 있습니다. 각각의 프로젝트들이 상당히 난이도가 있어보이지만, 선배개발자와 함께하는 멘토링 방식이기때문에 도전해볼만 하다고 생각합니다. 이력서상에서도 유의깊게 볼 것 같습니다.7월에 모집하며 다음주 월요일에 결과가 나옵니다. 제발…얼마 없는 시간을 쪼개서 자기개발에 투자하는 모든 직장인분들에게 후회없는 경험이 되기를 바랍니다." }, { "title": "2022년 1회 정보처리기사 합격 후기", "url": "/posts/2022%EB%85%84-1%ED%9A%8C-%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC-%ED%95%A9%EA%B2%A9-%ED%9B%84%EA%B8%B0/", "categories": "커리어 여정", "tags": "정보처리기사, 자격증", "date": "2022-06-25 15:51:00 +0900", "snippet": "지난주에 2022년 제 1회 정보처리기사 실기 최종합격자 발표가 있었고, 곧바로 2회 실기 원서접수가 있었습니다. 저는 운좋게도 첫 도전에 필기와 실기까지 합격하게 됐습니다.있어도 크게 메리트는 없지만 없으면 괜히 신경쓰이는 이 자격증을 빨리 끝내버리고싶은 분들이 많을 거라고 생각합니다. 그래서 블로그 첫 포스팅으로 제가 정보처리기사를 준비한 과정을 공유해드리고자 합니다. 참고로 비전공자에 현직자입니다.왜 취득해야 하는가?이 포스팅을 보시는 분들은 대부분 이미 자격증을 딸 결심을 하고계실겁니다. 동기부여라도 되고자 자격증을 따면 좋은점을 나열해보았습니다. 없어서 생기는 불이익을 면할 수 있다. (SI업체 취업, 정부프로젝트 투입 등) 비전공자일시 부족한 CS지식을 공부할 기회가 될 수 있다. 한번 따면 만료되는 일 없이 평생 가지고있을 수 있다. 기술사 시험 응시자격 중 실무경력 6~9년이 기사 보유시 4년으로 줄어든다. 시험일정이라도 있어야 사람이 공부를 한다.개인적으로 취업준비시 포토폴리오, 학생일경우에는 학점이 더 중요하다고 생각하지만 준비하는데 오래 걸리지 않으니 가볍게 도전해보셨으면 합니다. 기술사에 대한 얘기는 나중에 정리해서 포스팅할 기회가 있었으면 좋겠네요.필기 준비과정필기시험 준비기간은 원서접수인 01/24부터 시험일인 03/05까지 약 한달 반 정도였습니다. 원래 계획은 1달동안 전체범위 1회독하고 2주동안 기출 공부였지만, 게으름으로 인해 1달 반동안 1회독하고 기출공부를 급하게 하루정도 밤새서 했습니다. 실 공부시간을 따져보면 2주정도면 충분했던것같습니다.범위가 많아 1회독을 하다 지겨워서 포기해버릴 수도 있겠다는 생각에 인프런에서 정보처리기사 강의를 들었습니다. 때마침 이벤트로 무료로 풀리기도 했고요.인프런 수료증은 언제봐도 기분 좋네요. 강의 하나를 보고 강의에서 나간 진도만큼 책을 보는 식으로 진행했습니다. 책만 보는게 벅차신 분들은 저처럼 진도를 빼보시길 바랍니다.시험은 기출문제에서 주로 나왔습니다. 1회독은 보다가 놓치거나 이해못하는게 있어도 가볍게 넘어가며 전체 범위를 보는 것을 목표로 하시고, 기출문제를 외우고 오답체크하시는게 좋은 방법인 것 같습니다.실기 준비과정실기는 준비하기 정말 막막했습니다. 인터넷에 정리되어있는 필답형 암기 노트를 외워보려고 했으나 제1과목도 넘기지 못하고 매번 포기했습니다. 저처럼 암기에 약하신 분들은 추천하지 않습니다. 암기때문에 슬럼프가 와서 준비를 제대로 하지 못하다가 저에게 맞는 방법을 찾았는데, 역시 기출 위주로 공부하는 것이었습니다.실기시험은 시험문제를 공개하지는 않지만, 대단하신 분들이 실기시험을 보신 후 문제를 기억해놨다가 복원해놓은 것들을 인터넷에서 찾을 수 있습니다. 또한 유투브에 실기문제를 풀이해주는 동영상이 있습니다. 저는 이 두가지의 도움을 받아 기출문제를 공부했습니다. 필답형의 경우 해당 문제와 관련된 개념만 외웠고, 프로그래밍 문제(특히 비전공자에게 낯선 비트연산자의 경우)는 이해될때까지 동영상을 돌려봤습니다.사실 기출문제 위주로 출제될지는 운에 맞겨야 하지만 암기에 취약한 저에게는 최선의 방법이었던것 같습니다. 필기를 준비한지 얼마 되지 않아 개념이 머릿속에 남아있던 것도 도움이 됐습니다.합격 후기대단한 자격증은 아니지만 기념으로 발급해봤습니다. 아직 개발자로의 여정에 많은 관문이 남아있습니다. 정보처리기사를 준비하시는 여러분들도 지체없이 도전에 성공하시고 더 좋은 기회를 찾아나서기를 바랍니다." } ]
